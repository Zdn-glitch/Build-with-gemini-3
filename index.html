<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Glass Particles</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
        }
        canvas { display: block; }
        
        /* --- LIQUID GLASS UI --- */
        #dock-container {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 100;
            width: 90%;
            max-width: 800px;
        }

        /* Status Pill (Floating above main dock) */
        #status-pill {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        /* Main Glass Dock */
        #glass-dock {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 16px 24px;

            /* Apple-style Glass Effect */
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 4px 30px rgba(0, 0, 0, 0.1),
                inset 0 0 0 1px rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border-radius: 24px;
        }

        /* Separator Line */
        .divider {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 8px;
        }

        /* Buttons */
        button {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 10px 18px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateY(-2px);
        }

        button.active {
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Color Picker Styling */
        .color-wrapper {
            position: relative;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-wrapper:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.8);
        }
        input[type="color"] {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            cursor: pointer;
            border: none;
            padding: 0;
            margin: 0;
        }

        /* Camera Preview (Hidden) */
        #input_video { display: none; }

        /* Loader Overlay */
        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 12px;
            color: white;
            z-index: 200;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <!-- UI Dock -->
    <div id="dock-container">
        <!-- Floating Status Pill -->
        <div id="status-pill">
            <span id="gesture-info">Initialize Camera...</span>
        </div>

        <!-- Main Glass Controls -->
        <div id="glass-dock">
            
            <!-- Shape Buttons -->
            <button class="shape-btn active" onclick="setShape('heart')">Heart</button>
            <button class="shape-btn" onclick="setShape('flower')">Flower</button>
            <button class="shape-btn" onclick="setShape('saturn')">Saturn</button>
            <button class="shape-btn" onclick="setShape('complex')">Buddha</button>
            <button class="shape-btn" onclick="setShape('fireworks')">Fireworks</button>
            
            <div class="divider"></div>

            <!-- Color Picker -->
            <div class="color-wrapper" title="Change Color">
                <input type="color" id="colorPicker" value="#00d2ff">
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loader">Loading AI Vision...</div>

    <!-- Hidden Video for MediaPipe -->
    <video id="input_video"></video>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.18;
        let currentShape = 'heart';
        let targetColor = new THREE.Color(0x00d2ff);

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 18;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE TEXTURE ---
        const getTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.Texture(canvas);
        };
        const particleTexture = getTexture();
        particleTexture.needsUpdate = true;

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // Random start
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            color: targetColor,
            map: particleTexture,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE MATH ---
        function generateShape(type) {
            const tempPos = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                
                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    // Heart curve
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random() - 0.5) * 5;
                    // Normalize size
                    x *= 0.35; y *= 0.35;
                } 
                else if (type === 'flower') {
                    // Rose curve 3D
                    const r = 5 * Math.cos(2 * (Math.random() * Math.PI * 2));
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 2;
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = Math.sin(theta * 6) * 2;
                }
                else if (type === 'saturn') {
                    const isRing = Math.random() > 0.35;
                    if(isRing) {
                        const theta = Math.random() * Math.PI * 2;
                        const rad = 7 + Math.random() * 2.5;
                        x = rad * Math.cos(theta);
                        z = rad * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.1;
                    } else {
                        const r = 3.5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                    // Tilt Saturn
                    const tilt = 0.5;
                    const yt = y * Math.cos(tilt) - z * Math.sin(tilt);
                    const zt = y * Math.sin(tilt) + z * Math.cos(tilt);
                    y = yt; z = zt;
                }
                else if (type === 'complex') {
                    // Abstract Spirals
                    const t = Math.random() * 100;
                    const r = i / PARTICLE_COUNT * 8;
                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = Math.sqrt(r) * Math.cos(t * 2); 
                }
                else if (type === 'fireworks') {
                    // Explosion sphere
                    const r = 10 * Math.cbrt(Math.random()); 
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
        }

        generateShape('heart');

        // --- INTERACTION ---
        function setShape(shapeName) {
            currentShape = shapeName;
            generateShape(shapeName);
            
            // Update UI Active State
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            targetColor.set(e.target.value);
            material.color = targetColor;
        });

        // --- HAND TRACKING VARS ---
        let handDistance = 0.5;
        let handTension = 0;
        let smoothedScale = 1;
        let smoothedTension = 0;

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('input_video');
        const loader = document.getElementById('loader');
        const gestureInfo = document.getElementById('gesture-info');
        const statusPill = document.getElementById('status-pill');

        function onResults(results) {
            loader.style.opacity = '0'; // Hide loader once active

            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                // 1. Distance (Expansion)
                const dx = hand1[0].x - hand2[0].x;
                const dy = hand1[0].y - hand2[0].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                handDistance = Math.min(Math.max((dist - 0.1) * 3, 0.4), 3.0);

                // 2. Tension (Fist)
                const isFist = (hand) => {
                    const tip = hand[8]; // Index tip
                    const wrist = hand[0];
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    return d < 0.12 ? 1 : 0;
                };

                const t1 = isFist(hand1);
                const t2 = isFist(hand2);
                handTension = (t1 + t2) / 2;

                gestureInfo.innerText = "Hands Connected";
                gestureInfo.style.color = "#4ade80"; // Green text

            } else {
                // No hands detected
                handDistance = 1; 
                handTension = 0;
                gestureInfo.innerText = "Show both hands...";
                gestureInfo.style.color = "rgba(255,255,255,0.7)";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Smooth Inputs
            smoothedScale += (handDistance - smoothedScale) * 0.08;
            smoothedTension += (handTension - smoothedTension) * 0.1;

            // Global Transforms
            particles.rotation.y = time * 0.15;
            particles.scale.setScalar(smoothedScale);

            // Particle Physics
            const posAttribute = geometry.attributes.position;
            const currentPos = posAttribute.array;
            
            // Jitter increases with tension (fists)
            const jitter = smoothedTension * 0.3;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx = targetPositions[ix];
                let ty = targetPositions[iy];
                let tz = targetPositions[iz];

                // If high tension, attract to center
                if(smoothedTension > 0.1) {
                    const attraction = 1.0 - (smoothedTension * 0.4); 
                    tx *= attraction;
                    ty *= attraction;
                    tz *= attraction;
                }

                const speed = 4.0 * delta;

                currentPos[ix] += (tx - currentPos[ix]) * speed;
                currentPos[iy] += (ty - currentPos[iy]) * speed;
                currentPos[iz] += (tz - currentPos[iz]) * speed;

                if (jitter > 0.01) {
                    currentPos[ix] += (Math.random() - 0.5) * jitter;
                    currentPos[iy] += (Math.random() - 0.5) * jitter;
                    currentPos[iz] += (Math.random() - 0.5) * jitter;
                }
            }
            
            posAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
